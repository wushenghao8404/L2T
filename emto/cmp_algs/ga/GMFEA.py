import numpy as np
from copy import deepcopy
import emto.evol_operator as eo


class GMFEA:
    '''
        Implementation of multifactorial evolutionary algorithm with differential vector
        Ref: @article{ding2017generalized,
                      title={Generalized multitasking for evolutionary optimization of expensive problems},
                      author={Ding, Jinliang and Yang, Cuie and Jin, Yaochu and Chai, Tianyou},
                      journal={IEEE Transactions on Evolutionary Computation},
                      volume={23},
                      number={1},
                      pages={44--58},
                      year={2017},
                      publisher={IEEE}
                    }
    '''

    def __init__(self, env):
        self.env = env
        self.tasks = None
        self.rmp = 0.3  # random mating probability, a key parameter in MFEA algorithm family
        self.phi = 0.1
        self.theta = 0.02
        self.top = 0.2

    def run(self, env_seed):
        _, env_info = self.env.reset(seed=env_seed)
        assert self.env.n_tasks == 2, 'Current version of GMFEA does not support evolutionary multitasking with more than 2 tasks'
        self.task_max_nfe = self.env.task_max_nfe
        self.rec_nfe = self.env.rec_nfe
        self.max_nfe = self.env.max_nfe
        self.nfe = 0
        self.task_ids = list(np.arange(self.env.n_tasks))

        # check whether the tasks are with different dimensions
        flag_unequal_dims = False
        t_id_h = None  # the task id with higher dimensions
        t_id_l = None  # the task id with lower dimensions
        if self.env.tasks[0].dim > self.env.tasks[1].dim:
            flag_unequal_dims = True
            t_id_h = 0  # the task id with higher dimensions
            t_id_l = 1  # the task id with lower dimensions
        elif self.env.tasks[0].dim < self.env.tasks[1].dim:
            flag_unequal_dims = True
            t_id_h = 1
            t_id_l = 0

        # prepare the prerequisites for running the algorithm
        task_mus = np.zeros((self.env.n_tasks, self.env.n_dims))
        shift = np.zeros((self.env.n_tasks, self.env.n_dims))
        ctr_pt = 0.5 * (self.env.xlb + self.env.xub)
        alpha = 0.0
        n_top = int(self.top * self.env.pop_size_per_task)
        parent_pops = [self.env.ev_procs[task_id].cur_pop for task_id in range(self.env.n_tasks)]

        if flag_unequal_dims:
            # perform decision variable shuffling strategy
            sr_ = np.random.permutation(self.env.n_dims)  # shuffle random vector for the population
            tmp_pop = parent_pops[t_id_h][np.random.randint(self.env.pop_size_per_task, size=(self.env.pop_size_per_task,)),:]
            tmp_pop[:, sr_[:self.env.tasks[t_id_l].dim]] = parent_pops[t_id_l][:, :self.env.tasks[t_id_l].dim]
            parent_pops[t_id_l] = tmp_pop

        for gen in range(self.env.max_gen):
            # print('gen',gen,'error',[task.get_error() for task in self.env.tasks])
            offspring_pops = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task, self.env.n_dims), fill_value=np.nan)
            offspring_fits = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task), fill_value=np.nan)
            offspring_count = [0] * self.env.n_tasks

            parent_lpop = deepcopy(parent_pops[0])  # different from MFEA, the parent pop is obtained by decision variable shuffling first
            parent_task_ids = np.array([0] * self.env.pop_size_per_task)
            for task_id in range(1, self.env.n_tasks):
                parent_lpop = np.concatenate((parent_lpop, parent_pops[task_id]))
                parent_task_ids = np.r_[parent_task_ids, np.array([task_id] * self.env.pop_size_per_task)]

            s_ = np.random.permutation(parent_lpop.shape[0])
            half_lpop_size = len(s_) // 2

            for i in range(half_lpop_size):
                i1 = s_[i]
                i2 = s_[i + half_lpop_size]
                p1_task_id = parent_task_ids[i1]  # serve as target task parent
                p2_task_id = parent_task_ids[i2]  # serve as source task parent

                if p1_task_id == p2_task_id:
                    # the target offsprings are generated by self evolution (i.e., SBX + polynomial mutate)
                    child1, child2 = eo.simulated_binary_crossover(parent_lpop[i1], parent_lpop[i2], yita_c=self.env.ev_procs[p1_task_id]._yita_c)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = eo.polynomial_mutation(child1, yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_count[p1_task_id] += 1
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = eo.polynomial_mutation(child2, yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_count[p2_task_id] += 1
                elif np.random.rand() < self.rmp:
                    # inter-task knowledge transfer by decision variable translation strategy, and SBX between
                    # individuals from two tasks, followed by polynomial mutation
                    parent1_tr = parent_lpop[i1] + shift[p1_task_id]  # shift to ctr point
                    parent2_tr = parent_lpop[i2] + shift[p2_task_id]  # shift to ctr point
                    child1, child2 = eo.simulated_binary_crossover(parent1_tr, parent2_tr, yita_c=self.env.ev_procs[p1_task_id]._yita_c)
                    child1 -= shift[p1_task_id]  # shift back to original space
                    child2 -= shift[p2_task_id]  # shift back to original space
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = eo.polynomial_mutation(child1, yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_count[p1_task_id] += 1
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = eo.polynomial_mutation(child2, yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_count[p2_task_id] += 1
                else:
                    # both the target and source offspring are generated by self evolution (i.e., polynomial mutate)
                    child1 = eo.polynomial_mutation(parent_lpop[i1], yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = child1
                    offspring_count[p1_task_id] += 1
                    child2 = eo.polynomial_mutation(parent_lpop[i2], yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = child2
                    offspring_count[p2_task_id] += 1

            assert (np.array(offspring_count) == self.env.pop_size_per_task).all(), 'The offspring count for all pops should be equal to pop size'

            for task_id in range(self.env.n_tasks):
                if flag_unequal_dims:
                    if task_id == t_id_l:
                        task_mus[t_id_l, :self.env.tasks[t_id_l].dim] = task_mus[t_id_l, sr_[:self.env.tasks[t_id_l].dim]]
                        offspring_pops[t_id_l][:, :self.env.tasks[t_id_l].dim] = offspring_pops[t_id_l][:, sr_[:self.env.tasks[t_id_l].dim]]

                # clip the population to satisfy box constraint
                offspring_pops[task_id] = np.clip(offspring_pops[task_id], self.env.xlb, self.env.xub)

                # fitness evaluation
                offspring_fits[task_id] = self.env.tasks[task_id](offspring_pops[task_id])

                # update population by selection
                self.env.ev_procs[task_id].update(offspring_pops[task_id], offspring_fits[task_id])

            # update population statistics
            if gen >= self.phi * self.env.max_gen and gen % int(self.theta * self.env.max_gen) == 0:
                alpha = (gen / self.env.max_gen) ** 2
                for task_id in range(self.env.n_tasks):
                    sorted_id = np.argsort(self.env.ev_procs[task_id].cur_fit)
                    task_mus[task_id] = np.mean(self.env.ev_procs[task_id].cur_pop[sorted_id[:n_top]], axis=0)

            parent_pops = [self.env.ev_procs[task_id].cur_pop for task_id in range(self.env.n_tasks)]

            if flag_unequal_dims:
                # perform decision variable shuffling strategy
                sr_ = np.random.permutation(self.env.n_dims)  # shuffle random vector for the population
                tmp_pop = parent_pops[t_id_h][np.random.randint(self.env.pop_size_per_task, size=(self.env.pop_size_per_task,)), :]
                tmp_pop[:, sr_[:self.env.tasks[t_id_l].dim]] = parent_pops[t_id_l][:, :self.env.tasks[t_id_l].dim]
                parent_pops[t_id_l] = tmp_pop

            # update shift vectors for decision variable translation strategy
            for task_id in range(self.env.n_tasks):
                if flag_unequal_dims:
                    if task_id == t_id_l:
                        tmp_task_mu = deepcopy(task_mus[t_id_h])
                        tmp_task_mu[sr_[:self.env.tasks[t_id_l].dim]] = task_mus[t_id_l, :self.env.tasks[t_id_l].dim]
                        task_mus[t_id_l] = tmp_task_mu
                shift[task_id] = alpha * (ctr_pt - task_mus[task_id])

        y_trajectory = []
        y_final = np.array([np.min(task._y_trajectory[:self.task_max_nfe]) - task.f.fopt for task in self.env.tasks])
        for task_id in range(self.env.n_tasks):
            task_y_trajectory = np.array(self.env.tasks[task_id]._y_trajectory) - self.env.tasks[task_id].f.fopt
            for i in range(1, len(task_y_trajectory)):
                task_y_trajectory[i] = np.min([task_y_trajectory[i], task_y_trajectory[i - 1]])
            y_trajectory.append(task_y_trajectory[:self.task_max_nfe:self.rec_nfe])
        y_trajectory = np.array(y_trajectory).T
        self.clean()
        return y_final, y_trajectory, env_info

    def clean(self):
        self.tasks = None


if __name__ == '__main__':
    import emto
    import gymnasium as gym

    env = gym.make('l2t_emto-v5', problem_name='bbob-v1')
    algo = GMFEA(env)
    for env_seed in range(2):
        print(algo.run(env_seed))

