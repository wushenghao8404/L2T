import numpy as np
from copy import deepcopy
import emto.evol_operator as eo


class ATMFEA:
    '''
        Implementation of affine-transformation-based multifactorial evolutionary algorithm
        Ref: @article{xue2020affine,
                      title={Affine transformation-enhanced multifactorial optimization for heterogeneous problems},
                      author={Xue, Xiaoming and Zhang, Kai and Tan, Kay Chen and Feng, Liang and Wang, Jian and Chen,
                              Guodong and Zhao, Xinggang and Zhang, Liming and Yao, Jun},
                      journal={IEEE Transactions on Cybernetics},
                      volume={52},
                      number={7},
                      pages={6217--6231},
                      year={2020},
                      publisher={IEEE}}
    '''

    def __init__(self, env):
        self.env = env
        self.tasks = None
        self.rmp = 0.3   # random mating probability, a key parameter in MFEA algorithm family
        self.alpha = 0.5  # update rate for the distribution parameter update

    def run(self, env_seed):
        _, env_info = self.env.reset(seed=env_seed)
        self.task_max_nfe = self.env.task_max_nfe
        self.rec_nfe = self.env.rec_nfe
        self.max_nfe = self.env.max_nfe
        self.nfe = 0
        self.task_ids = list(np.arange(self.env.n_tasks))

        # initialize population distribution parameter
        self.task_mus = np.array([np.mean(ev_proc.cur_pop, axis=0) for ev_proc in self.env.ev_procs])
        self.task_sigs = np.array([np.std(ev_proc.cur_pop, axis=0) ** 2 for ev_proc in self.env.ev_procs])

        self.at_params = {}

        for gen in range(self.env.max_gen):
            # print('gen',gen,'error',[task.get_error() for task in self.env.tasks])

            # reset affine matrix
            learn_flag = np.full(shape=(self.env.n_tasks, self.env.n_tasks), fill_value=False)
            for i in range(self.env.n_tasks):
                for j in range(self.env.n_tasks):
                    self.at_params[str(i) + '-' + str(j)] = (None, None)

            offspring_pops = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task, self.env.n_dims),
                                     fill_value=np.nan)
            offspring_fits = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task), fill_value=np.nan)
            offspring_count = [0] * self.env.n_tasks

            parent_lpop = deepcopy(self.env.ev_procs[0].cur_pop)
            parent_task_ids = np.array([0] * self.env.pop_size_per_task)
            for task_id in range(1, self.env.n_tasks):
                parent_lpop = np.concatenate((parent_lpop, self.env.ev_procs[task_id].cur_pop))
                parent_task_ids = np.r_[parent_task_ids, np.array([task_id] * self.env.pop_size_per_task)]

            s_ = np.random.permutation(parent_lpop.shape[0])
            half_lpop_size = len(s_) // 2

            for i in range(half_lpop_size):
                i1 = s_[i]
                i2 = s_[i + half_lpop_size]
                p1_task_id = parent_task_ids[i1]  # serve as target task parent
                p2_task_id = parent_task_ids[i2]  # serve as source task parent

                if p1_task_id == p2_task_id:
                    # the target offsprings are generated by self evolution (i.e., SBX + polynomial mutate)
                    child1, child2 = eo.simulated_binary_crossover(parent_lpop[i1], parent_lpop[i2],
                                                                   yita_c=self.env.ev_procs[p1_task_id]._yita_c)
                    mut_child1 = eo.polynomial_mutation(child1, yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = mut_child1
                    offspring_count[p1_task_id] += 1
                    mut_child2 = eo.polynomial_mutation(child2, yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = mut_child2
                    offspring_count[p2_task_id] += 1
                elif np.random.rand() < self.rmp:
                    # learn the affine matrix first if it has not been instantiated
                    if not learn_flag[p1_task_id, p2_task_id]:
                        # from task p1 to task p2
                        self.at_params[str(p2_task_id) + '-' + str(p1_task_id)] = \
                            learn_affine_transform_param(self.task_mus[p1_task_id], self.task_sigs[p1_task_id],
                                                         self.task_mus[p2_task_id], self.task_sigs[p2_task_id],)
                        learn_flag[p1_task_id, p2_task_id] = True
                    if not learn_flag[p2_task_id, p1_task_id]:
                        # from task p1 to task p2
                        self.at_params[str(p1_task_id) + '-' + str(p2_task_id)] = \
                            learn_affine_transform_param(self.task_mus[p2_task_id], self.task_sigs[p2_task_id],
                                                         self.task_mus[p1_task_id], self.task_sigs[p1_task_id],)
                        learn_flag[p2_task_id, p1_task_id] = True

                    # perform affine transformation between two tasks
                    child1 = self.at_params[str(p2_task_id) + '-' + str(p1_task_id)][0].dot(parent_lpop[i2]) + \
                             self.at_params[str(p2_task_id) + '-' + str(p1_task_id)][1]
                    child2 = self.at_params[str(p1_task_id) + '-' + str(p2_task_id)][0].dot(parent_lpop[i1]) + \
                             self.at_params[str(p1_task_id) + '-' + str(p2_task_id)][1]

                    # perform post-transformation evolution operators as self-evolution
                    child1, child2 = \
                        eo.simulated_binary_crossover(child1, child2, yita_c=self.env.ev_procs[p1_task_id]._yita_c)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = \
                        eo.polynomial_mutation(child1, yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_count[p1_task_id] += 1
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = \
                        eo.polynomial_mutation(child2, yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_count[p2_task_id] += 1
                else:
                    # both the target and source offspring are generated by self evolution (i.e., polynomial mutate)
                    child1 = eo.polynomial_mutation(parent_lpop[i1], yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = child1
                    offspring_count[p1_task_id] += 1
                    child2 = eo.polynomial_mutation(parent_lpop[i2], yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = child2
                    offspring_count[p2_task_id] += 1

            assert (np.array(offspring_count) == self.env.pop_size_per_task).all(),\
                'The offspring count for all pops should be equal to pop size'

            for task_id in range(self.env.n_tasks):
                # clip the population to satisfy box constraint
                offspring_pops[task_id] = np.clip(offspring_pops[task_id], self.env.xlb, self.env.xub)

                # fitness evaluation
                offspring_fits[task_id] = self.env.tasks[task_id](offspring_pops[task_id])

                # update population by selection
                self.env.ev_procs[task_id].update(offspring_pops[task_id], offspring_fits[task_id])

                # update population distribution parameter
                self.task_mus[task_id] = (1 - self.alpha) * self.task_mus[task_id] + self.alpha * np.mean(
                    self.env.ev_procs[task_id].cur_pop, axis=0)
                self.task_sigs[task_id] = (1 - self.alpha) * self.task_sigs[task_id] + self.alpha * (np.std(
                    self.env.ev_procs[task_id].cur_pop, axis=0) ** 2 + 1e-25)

        y_trajectory = []
        y_final = np.array([np.min(task._y_trajectory[:self.task_max_nfe]) - task.f.fopt for task in self.env.tasks])
        for task_id in range(self.env.n_tasks):
            task_y_trajectory = np.array(self.env.tasks[task_id]._y_trajectory) - self.env.tasks[task_id].f.fopt
            for i in range(1, len(task_y_trajectory)):
                task_y_trajectory[i] = np.min([task_y_trajectory[i], task_y_trajectory[i - 1]])
            y_trajectory.append(task_y_trajectory[:self.task_max_nfe:self.rec_nfe])
        y_trajectory = np.array(y_trajectory).T
        self.clean()
        return y_final, y_trajectory, env_info

    def clean(self):
        self.tasks = None


def learn_affine_transform_param(mu_t, sig_t, mu_s, sig_s):
    assert sig_t.ndim == 1 and sig_s.ndim == 1, \
        'Input sigma should be a vector (to be diagonalized as matrix in this function)'
    inv_sig_t = np.diag(1/sig_t)
    inv_sig_s = np.diag(1/sig_s)
    L_t = np.linalg.cholesky(inv_sig_t)
    L_s = np.linalg.cholesky(inv_sig_s)
    aft_w = np.linalg.inv(L_t.T).dot(L_s)
    aft_b = mu_t - aft_w.dot(mu_s)
    return (aft_w, aft_b)


if __name__ == '__main__':
    import emto
    import gymnasium as gym

    env = gym.make('l2t_emto-v5', problem_name='bbob-v1')
    algo = ATMFEA(env)
    for env_seed in range(2):
        print(algo.run(env_seed))

