import numpy as np
from copy import deepcopy
import emto.evol_operator as eo


class MFEA_AKT:
    '''
        Implementation of multifactorial evolutionary algorithm with adaptive knowledge transfer
        Ref: @article{zhou2020toward,
                      title={Toward adaptive knowledge transfer in multifactorial evolutionary computation},
                      author={Zhou, Lei and Feng, Liang and Tan, Kay Chen and Zhong, Jinghui and Zhu, Zexuan and Liu, Kai and Chen, Chao},
                      journal={IEEE transactions on cybernetics},
                      volume={51},
                      number={5},
                      pages={2563--2576},
                      year={2020},
                      publisher={IEEE}
                    }
    '''

    def __init__(self, env):
        self.env = env
        self.tasks = None
        self.gap = 20
        self.rmp = 0.3   # random mating probability, a key parameter in MFEA algorithm family

    def run(self, env_seed):
        _, env_info = self.env.reset(seed=env_seed)
        self.task_max_nfe = self.env.task_max_nfe
        self.rec_nfe = self.env.rec_nfe
        self.max_nfe = self.env.max_nfe
        self.nfe = 0
        self.task_ids = list(np.arange(self.env.n_tasks))

        # memory of the algorithm
        self.cr_f = np.random.randint(6, size=(self.env.n_tasks, self.env.pop_size_per_task)) + 1  # crossover factor
        self.cfb_record = []  # record the best crossover factor along the search process
        INT_NAN = int((self.env.n_tasks * self.env.pop_size_per_task) * 100) # define a nan integer to make sure an exception
        # will be thrown out in case the value of the retrieved variable is not properly assigned

        for gen in range(self.env.max_gen):
            # print('gen',gen,'error',[task.get_error() for task in self.env.tasks])

            # prepare necessary information required for updating the offspring population
            offspring_pops = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task, self.env.n_dims), fill_value=np.nan)
            offspring_fits = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task), fill_value=np.nan)
            offspring_count = [0] * self.env.n_tasks
            offspring_par_ids = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task),
                                        dtype=np.int_, fill_value=INT_NAN)  # child's parent id
            offspring_cr_f = np.full(shape=(self.env.n_tasks, self.env.pop_size_per_task),
                                     dtype=np.int_, fill_value=INT_NAN)  # crossover factor

            # prepare necessary information required for updating the parent population
            parent_lpop = deepcopy(self.env.ev_procs[0].cur_pop)
            parent_task_ids = np.array([0] * self.env.pop_size_per_task)
            parent_ids = np.tile(np.arange(self.env.pop_size_per_task), self.env.n_tasks)  # index of the parent id
            parent_cr_f = self.cr_f.flatten()
            for task_id in range(1, self.env.n_tasks):
                parent_lpop = np.concatenate((parent_lpop, self.env.ev_procs[task_id].cur_pop))
                parent_task_ids = np.r_[parent_task_ids, np.array([task_id] * self.env.pop_size_per_task)]

            s_ = np.random.permutation(parent_lpop.shape[0])
            assert len(s_) % 2 == 0, 'For pairwise-updating genetic algorithm, the population size should be an even number'
            half_lpop_size = len(s_) // 2

            # produce offspring population
            for i in range(half_lpop_size):
                i1 = s_[i]
                i2 = s_[i + half_lpop_size]
                p1_task_id = parent_task_ids[i1]  # serve as target task parent
                p2_task_id = parent_task_ids[i2]  # serve as source task parent

                if p1_task_id == p2_task_id:
                    # the target offsprings are generated by self evolution (i.e., SBX + polynomial mutate)
                    child1, child2 = \
                        eo.simulated_binary_crossover(parent_lpop[i1], parent_lpop[i2],
                                                      yita_c=self.env.ev_procs[p1_task_id]._yita_c)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = \
                        eo.polynomial_mutation(child1, yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_cr_f[p1_task_id, offspring_count[p1_task_id]] = parent_cr_f[i1]
                    offspring_count[p1_task_id] += 1

                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = \
                        eo.polynomial_mutation(child2, yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_cr_f[p2_task_id, offspring_count[p2_task_id]] = parent_cr_f[i2]
                    offspring_count[p2_task_id] += 1

                elif np.random.rand() < self.rmp:
                    # inter-task knowledge transfer by hyper crossover
                    chosen_alpha = parent_cr_f[np.random.choice([i1, i2])]
                    r_ = np.random.permutation(2)
                    p1_id = [i1, i2][r_[0]]
                    p2_id = [i1, i2][r_[1]]
                    child1, child2 = self.hyper_crossover(parent_lpop[i1], parent_lpop[i2], int(chosen_alpha))
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = child1
                    offspring_cr_f[p1_task_id, offspring_count[p1_task_id]] = chosen_alpha
                    offspring_par_ids[p1_task_id, offspring_count[p1_task_id]] = parent_ids[p1_id] # record intermediate parent
                    offspring_count[p1_task_id] += 1

                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = child2
                    offspring_cr_f[p2_task_id, offspring_count[p2_task_id]] = chosen_alpha
                    offspring_par_ids[p2_task_id, offspring_count[p2_task_id]] = parent_ids[p2_id] # record intermediate parent
                    offspring_count[p2_task_id] += 1
                else:
                    # both the target and source offspring are generated by self evolution (i.e., polynomial mutate)
                    child1 = eo.polynomial_mutation(parent_lpop[i1], yita_m=self.env.ev_procs[p1_task_id]._yita_m)
                    offspring_pops[p1_task_id][offspring_count[p1_task_id]] = child1
                    offspring_count[p1_task_id] += 1
                    child2 = eo.polynomial_mutation(parent_lpop[i2], yita_m=self.env.ev_procs[p2_task_id]._yita_m)
                    offspring_pops[p2_task_id][offspring_count[p2_task_id]] = child2
                    offspring_count[p2_task_id] += 1

            assert (np.array(offspring_count) == self.env.pop_size_per_task).all(), \
                'The offspring count for all pops should be equal to pop size'

            # fitness evaluation
            for task_id in range(self.env.n_tasks):
                # clip the population to satisfy box constraint
                offspring_pops[task_id] = np.clip(offspring_pops[task_id], self.env.xlb, self.env.xub)
                offspring_fits[task_id] = self.env.tasks[task_id](offspring_pops[task_id])

            # calculate the best crossover factor based on the history information
            n_improve = np.zeros(6)
            for task_id in range(self.env.n_tasks):
                for i in range(self.env.pop_size_per_task):
                    if offspring_par_ids[task_id, i] != INT_NAN:
                        child_fit = offspring_fits[task_id][i]
                        parent_fit = self.env.ev_procs[task_id].cur_fit[offspring_par_ids[task_id, i]]
                        alpha_id = offspring_cr_f[task_id, i] - 1
                        n_improve[alpha_id] = \
                            np.max([n_improve[alpha_id], (parent_fit - child_fit)/(np.abs(parent_fit) + 1e-20)])
            if n_improve.any():
                best_alpha_id = np.argmax(n_improve)
            else:
                if gen <= self.gap:
                    record_tmp = self.cfb_record
                else:
                    record_tmp = self.cfb_record[gen - self.gap: gen]
                if not record_tmp:
                    best_alpha_id = np.random.randint(6)
                else:
                    best_alpha_id = np.argmax(np.bincount(record_tmp)[1:])
            best_alpha = best_alpha_id + 1
            self.cfb_record.append(best_alpha)

            # update crossover factor of the offspring that were not produced by knowledge transfer
            for task_id in range(self.env.n_tasks):
                for i in range(self.env.pop_size_per_task):
                    if offspring_par_ids[task_id, i] != INT_NAN:
                        child_fit = offspring_fits[task_id][i]
                        parent_fit = self.env.ev_procs[task_id].cur_fit[offspring_par_ids[task_id, i]]
                        if (parent_fit - child_fit)/(np.abs(parent_fit) + 1e-20) < 0:
                            offspring_cr_f[task_id, i] = best_alpha
                    else:
                        offspring_cr_f[task_id, i] = np.random.choice([best_alpha, np.random.randint(6)+1])
                fit_u = np.r_[self.env.ev_procs[task_id].cur_fit, offspring_fits[task_id]]
                cr_f_u = np.r_[self.cr_f[task_id], offspring_cr_f[task_id]]
                sorted_id = np.argsort(fit_u)
                self.cr_f[task_id] = cr_f_u[sorted_id[:self.env.pop_size_per_task]]

            # update population by selection
            for task_id in range(self.env.n_tasks):
                self.env.ev_procs[task_id].update(offspring_pops[task_id], offspring_fits[task_id])

        y_trajectory = []
        y_final = np.array([np.min(task._y_trajectory[:self.task_max_nfe]) - task.f.fopt for task in self.env.tasks])
        for task_id in range(self.env.n_tasks):
            task_y_trajectory = np.array(self.env.tasks[task_id]._y_trajectory) - self.env.tasks[task_id].f.fopt
            for i in range(1, len(task_y_trajectory)):
                task_y_trajectory[i] = np.min([task_y_trajectory[i], task_y_trajectory[i - 1]])
            y_trajectory.append(task_y_trajectory[:self.task_max_nfe:self.rec_nfe])
        y_trajectory = np.array(y_trajectory).T
        self.clean()
        return y_final, y_trajectory, env_info

    def hyper_crossover(self, parent1, parent2, alpha: int):
        if alpha == 1:
            child1 = eo.two_point_crossover(parent1, parent2)
            child2 = eo.two_point_crossover(parent2, parent1)
        elif alpha == 2:
            child1 = eo.uniform_crossover(parent1, parent2)
            child2 = eo.uniform_crossover(parent2, parent1)
        elif alpha == 3:
            child1 = eo.arithmetic_crossover(parent1, parent2, lambda_=0.25)
            child2 = eo.arithmetic_crossover(parent2, parent1, lambda_=0.25)
        elif alpha == 4:
            child1 = eo.geometric_crossover(parent1, parent2, omega_=0.2)
            child2 = eo.geometric_crossover(parent2, parent1, omega_=0.2)
        elif alpha == 5:
            child1 = eo.blx_alpha_crossover(parent1, parent2, alpha_=0.3)
            child2 = eo.blx_alpha_crossover(parent2, parent1, alpha_=0.3)
        elif alpha == 6:
            child1, child2 = eo.simulated_binary_crossover(parent1, parent2, yita_c=2.0)
        else:
            raise Exception('Unexpected alpha for deciding crossover operator')
        return child1, child2

    def clean(self):
        self.tasks = None


if __name__ == '__main__':
    import emto
    import gymnasium as gym

    env = gym.make('l2t_emto-v5', problem_name='bbob-v1')
    algo = MFEA_AKT(env)
    for env_seed in range(2):
        print(algo.run(env_seed))

