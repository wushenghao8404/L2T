import gymnasium as gym
from copy import deepcopy
import numpy as np
from typing import Any, SupportsFloat, TypeVar, Optional
from gymnasium import spaces
import emto.evol_optimizer as evopt
import emto.evol_operator as eo
from scipy.stats import multivariate_normal
import config
import utils
import scipy
ObsType = TypeVar("ObsType")
RenderFrame = TypeVar("RenderFrame")


def get_modifier(env):
    if 'ppo-v0-ga' in env.env_kwargs['alg_name']:
        if env.base_solver_name != 'ga':
            raise Exception('In case of using ppo-v0-ga as training algorithm, the solver name should be binded to ga')
        return StepGAModifier()
    elif 'ppo-v0-spop' in env.env_kwargs['alg_name']:
        return PopStateModifier()
    elif 'ppo-v1' in env.env_kwargs['alg_name']:
        return PPOv1Modifier()
    else:
        return DummyModifier()


class EnvModifier:
    def __init__(self, alg_name):
        self.alg_name = alg_name

    def modified_env_init(self, env):
        raise NotImplementedError

    def modified_get_obs(self, env):
        raise NotImplementedError

    def modified_pop_init(self, env):
        raise NotImplementedError

    def modified_init_add_var(self, env):
        raise NotImplementedError

    def modified_step(self, env, action):
        raise NotImplementedError


class DummyModifier(EnvModifier):
    def __init__(self, alg_name=None):
        if alg_name is None:
            super().__init__('ppo-v0')
        else:
            super().__init__(alg_name)

    def modified_env_init(self, env):
        return False

    def modified_get_obs(self, env):
        return None, False

    def modified_pop_init(self, env):
        return False

    def modified_init_add_var(self, env):
        return False

    def modified_step(self, env, action):
        return False, None, None, None, None, None,


class PopStateModifier(DummyModifier):
    def __init__(self):
        super().__init__('ppo-v0-spop')

    def modified_env_init(self, env):
        # ------------------------------------------------Modification--------------------------------------------------
        env.common_features = []
        env.n_common_features = len(env.common_features)
        env.task_features = []
        env.n_task_features = len(env.task_features)
        env.static_features = []
        env.n_static_features = len(env.static_features)
        env.observation_space = spaces.Box(low=0, high=1, shape=(int(env.n_tasks * env.pop_size_per_task),env.n_dims + 1), dtype=np.float64)
        # --------------------------------------------------------------------------------------------------------------
        return True

    def modified_get_obs(self, env):
        obs = None
        for task_id in range(env.n_tasks):
            sorted_id = np.argsort(env.ev_procs[task_id].cur_fit)
            norm_ranks = np.argsort(sorted_id) / len(sorted_id)
            if task_id == 0:
                obs = np.c_[env.ev_procs[task_id].cur_pop, norm_ranks.reshape(-1, 1)]
            else:
                obs = np.r_[obs, np.c_[env.ev_procs[task_id].cur_pop, norm_ranks.reshape(-1, 1)]]
        return obs, True


class StepGAModifier(DummyModifier):
    def __init__(self):
        super().__init__('ga')

    def modified_step(self, env, action):
        # print('gen', env.gen)
        env.cur_action = action
        env.reset_tmp_var()
        count = [0] * env.n_tasks

        parent_lpop = deepcopy(env.ev_procs[0].cur_pop)
        parent_task_ids = np.array([0] * env.pop_size_per_task)
        sorted_ids = []
        kt_params = []
        for task_id in range(1, env.n_tasks):
            parent_lpop = np.concatenate((parent_lpop, env.ev_procs[task_id].cur_pop))
            parent_task_ids = np.r_[parent_task_ids, np.array([task_id] * env.pop_size_per_task)]

        for task_id in range(env.n_tasks):
            # sort the population from best to worst according to fitness
            sorted_ids.append(np.argsort(env.ev_procs[task_id].cur_fit))
            # add the translated kt action for each task
            kt_params.append(env.get_kt_param_from_action(env.cur_action[task_id, :]))

        s_ = np.random.permutation(parent_lpop.shape[0])

        half_lpop_size = len(s_) // 2

        for i in range(half_lpop_size):
            i1 = s_[i]
            i2 = s_[i + half_lpop_size]
            p1_task_id = parent_task_ids[i1]  # serve as target task parent
            p2_task_id = parent_task_ids[i2]  # serve as source task parent

            # retrieve the action values of knowledge transfer decision
            a1, a2, a3, a4, a5, a6 = kt_params[p1_task_id]

            if p1_task_id == p2_task_id:
                # the target offsprings are generated by env evolution (i.e., SBX + polynomial mutate)
                child1, child2 = eo.simulated_binary_crossover(parent_lpop[i1], parent_lpop[i2],
                                                               yita_c=env.ev_procs[p1_task_id]._yita_c)
                env.offspring_pops[p1_task_id][count[p1_task_id]] = eo.polynomial_mutation(child1, yita_m=env.ev_procs[
                    p1_task_id]._yita_m)
                count[p1_task_id] += 1
                env.offspring_pops[p2_task_id][count[p2_task_id]] = eo.polynomial_mutation(child2, yita_m=env.ev_procs[
                    p2_task_id]._yita_m)
                count[p2_task_id] += 1
            elif np.random.rand() < a1:
                # random selection of the transferred base vector
                sorted_id_s = sorted_ids[p1_task_id]
                rs_b = sorted_id_s[np.random.choice(np.arange(max(int(env.pop_size_per_task * a2), 1)))]

                # random permutation for sampling indices of the transferred differential vector
                rs_d = np.random.permutation(env.pop_size_per_task)
                rt_ = np.random.permutation(env.pop_size_per_task)

                # the target offspring is generated by parameterized knowledge transfer
                child1 = (1 - a3) * env.ev_procs[p1_task_id].cur_pop[rt_[0]] + a3 * env.ev_procs[p2_task_id].cur_pop[rs_b]
                child1 += a4 * ((1 - a5) * (env.ev_procs[p1_task_id].cur_pop[rt_[1]] - env.ev_procs[p1_task_id].cur_pop[rt_[2]]) +
                                a5 * (env.ev_procs[p2_task_id].cur_pop[rs_d[0]] - env.ev_procs[p2_task_id].cur_pop[rs_d[1]]))

                # sample random numbers required for binomial crossover-based knowledge transfer
                mask_binocr = np.random.binomial(1, a6, env.n_dims)  # for binomial crossover
                mask_binocr[np.random.randint(env.n_dims)] = 1
                child1 = mask_binocr * child1 + (1 - mask_binocr) * parent_lpop[i1]
                env.offspring_pops[p1_task_id][count[p1_task_id]] = child1
                env.transfer_masks[p1_task_id][count[p1_task_id]] = True
                count[p1_task_id] += 1

                # the source offspring is generated by env evolution (i.e., local perturbation by polynomial mutate)
                child2 = eo.polynomial_mutation(parent_lpop[i2], yita_m=env.ev_procs[p2_task_id]._yita_m)
                env.offspring_pops[p2_task_id][count[p2_task_id]] = child2
                count[p2_task_id] += 1
            else:
                # both the target and source offspring are generated by env evolution (i.e., polynomial mutate)
                child1 = eo.polynomial_mutation(parent_lpop[i1], yita_m=env.ev_procs[p1_task_id]._yita_m)
                env.offspring_pops[p1_task_id][count[p1_task_id]] = child1
                count[p1_task_id] += 1
                child2 = eo.polynomial_mutation(parent_lpop[i2], yita_m=env.ev_procs[p2_task_id]._yita_m)
                env.offspring_pops[p2_task_id][count[p2_task_id]] = child2
                count[p2_task_id] += 1

        assert (np.array(
            count) == env.pop_size_per_task).all(), 'The offspring count for all pops should be equal to pop size'

        for task_id in range(env.n_tasks):
            # clip the population to satisfy box constraint
            env.offspring_pops[task_id] = np.clip(env.offspring_pops[task_id], env.xlb, env.xub)

            # fitness evaluation
            env.offspring_fits[task_id] = env.tasks[task_id](env.offspring_pops[task_id])

            # calculate the scores of offspring relative to the parental population
            env.offspring_scores[task_id] = np.array(
                [np.sum(sol_fit < env.ev_procs[task_id].cur_fit) / env.pop_size_per_task
                 for sol_fit in env.offspring_fits[task_id]])

            # update population by selection
            env.ev_procs[task_id].update(env.offspring_pops[task_id], env.offspring_fits[task_id])

            env.update_task_stats(task_id)
            if env.env_mode == 'train':
                env.update_reward(task_id)

        obs, reward, done, truncated, info = env.update_step_stats()
        return True, obs, reward, done, truncated, info


class PPOv1Modifier(EnvModifier):
    def __init__(self):
        super().__init__('ppo-v1')

    def modified_env_init(self, env):
        # ------------------------------------------------Modification--------------------------------------------------
        env.common_features = ['oc1', 'oc2', 'oc3', 'oc4', 'oc5', ]
        env.n_common_features = len(env.common_features)
        env.task_features = ['oi1', 'oi2', 'oi3', 'oi4', 'oi5', 'oi6', 'oi7']
        env.n_task_features = len(env.task_features)
        env.static_features = ['os1', 'os2', ]
        env.n_static_features = len(env.static_features)
        env.n_frames = 2
        env.prev_dyn_obs = []
        env.obs_static = None
        env.sample_pop = env.lh.random(100)
        env.obs_dim = env.n_static_features + env.n_frames * (
                env.n_common_features + env.n_task_features * env.n_tasks
                + env.act_dim_per_task * env.n_tasks)
        env.observation_space = spaces.Box(low=0, high=1, shape=(env.obs_dim,), dtype=np.float64)
        # --------------------------------------------------------------------------------------------------------------
        return True

    def modified_get_obs(self, env):
        # ------------------------------------------------Modification--------------------------------------------------
        obs = deepcopy(env.obs_static)
        new_dyn_obs = np.concatenate(
            (env.get_obs_common_features(), env.get_obs_task_features(), env.cur_action.T.flatten()), axis=0)
        env.prev_dyn_obs.append(new_dyn_obs)
        if len(env.prev_dyn_obs) > env.n_frames:
            env.prev_dyn_obs.pop(0)
        elif len(env.prev_dyn_obs) < env.n_frames:
            for _ in range(env.n_frames - len(env.prev_dyn_obs)):
                obs = np.r_[obs, np.zeros_like(new_dyn_obs)]
        for i in range(len(env.prev_dyn_obs)):
            obs = np.r_[obs, env.prev_dyn_obs[i]]
        # --------------------------------------------------------------------------------------------------------------
        return obs, True

    def modified_pop_init(self, env):
        # ------------------------------------------------Modification----------------------------------------------
        if 'ppo-v1' in env.env_kwargs['alg_name']:
            for task_id, ev_proc in enumerate(env.ev_procs):
                s_ = np.argsort(env.sample_fits[task_id])
                ev_proc.setup(env.tasks[task_id], init_pop=env.sample_pop[s_[:env.pop_size_per_task]],
                              init_fit=env.sample_fits[task_id][s_[:env.pop_size_per_task]])
        # ----------------------------------------------------------------------------------------------------------
        return True

    def get_obs_static_features(self, env):
        obs_static_feats = []
        for feat_name in env.static_features:
            if feat_name == 'os1':
                sorted_ids = [np.argsort(env.sample_fits[task_id]) for task_id in range(env.n_tasks)]
                ranks = [np.argsort(sorted_ids[task_id]) for task_id in range(env.n_tasks)]
                pcc = np.corrcoef(ranks[0], ranks[1])[0, 1]
                obs_static_feats.append((pcc + 1) / 2)
            elif feat_name == 'os2':
                best_ids = [np.argmin(env.sample_fits[task_id]) for task_id in range(env.n_tasks)]
                obs_static_feats.append(np.sqrt(np.sum((env.sample_pop[best_ids[0]] - env.sample_pop[best_ids[1]]) ** 2))
                                        / np.sqrt(env.n_dims))
            else:
                raise Exception('Unexpected common feature name')
        return np.array(obs_static_feats)

    def modified_init_add_var(self, env):
        # ------------------------------------------------Modification--------------------------------------------------
        env.prev_dyn_obs = []
        env.sample_fits = [task(env.sample_pop) for task in env.tasks]
        env.obs_static = self.get_obs_static_features(env)
        # --------------------------------------------------------------------------------------------------------------
        return True


if __name__ == "__main__":
    pass